# Cos'è e cosa fa l'incapsulamento, fai degli esempi pratici

L'incapsulamento è uno dei principi fondamentali della OOP.
Definisce che gli oggetti hanno la possibilità di nascondere il proprio funzionamento interno, e di mostrare al resto del codice solo ciò che è strettamente necessario.

Noi applichiamo l'incapsulamento principalmente con le parole chiave:
Private, Protected, Public

Inoltre utiliziamo metodi chiamati Getter e Setter, che ci permettono di definire il modo in cui accediamo e modifichiamo i nostri attributi

Esempio:

private float credito;
public float Credito 
	get => credito
	set => 
		if(value < 0f) return;
		credito = value;

In questo caso, l'attributo credito è privato visto che vogliamo definire un comportamento specifico con il quale cambiare il suo valore.
Nel nostro programma non possiamo permettere un credito negativo, perciò usiamo il Setter per controllare che non si stia inserendo un valore "illegale"

Il Getter invece, essendo una funzione con un valore di ritorno, può essere usato per variabili computate

Esempio:

const int LIMITE_DEBITO = 100
private int debito;
public int DebitoDisponibile => LIMITE_DEBITO - debito;

In questo caso, abbiamo una proprietà DebitoDisponibile che ha solo il Getter, e ogni volta che vogliamo leggere da essa viene eseguita l'operazione LIMITE_DEBITO - debito e restituito il risultato
Non abbiamo aggiunto un setter visto che non vogliamo dare la possibilità ad un cliente (ovvero un utente o un altro programmatore) di cambiare il suo debito disponibile

# Cos'è e cosa fa l'ereditarietà, fai degli esempi pratici

L'ereditarietà è uno dei principi fondamentali della OOP.

Permette di creare una gerarchia di classi con un rapporto "Inherits From" 
(attenzione: il rapporto non è "Is A", quello dipende dal programmatore e non può essere forzato dal compilatore, come sappiamo dal principio di Liskov)

In C# questa è una gerarchia ad albero, dove ogni figlio ha un solo padre, visto che ogni classe può ereditare direttamente da solo una classe (altri linguaggi permettono l'ereditarietà multipla)

L'ereditarietà ci permette di riutilizzare il codice esposto in una classe padre (o superclasse) nelle classi figlie (o sottoclassi)

Possiamo in aggiunta sovrascrivere il funzionamento della superclasse tramite parole chiave come override (polimorfismo)

Esempio:

class Animale
	protected string specie;

	public string GetSpecie() 
		return specie;

	public void FaiVerso() 
		Print("L'animale fa un verso");

class Cane : Animale
	public override void FaiVerso() 
		Print("Il cane abbaia");

In questo caso, noi abbiamo accesso alla proprietà specie e al metodo GetSpecie(), e non dobbiamo riscriverli nella classe Cane per usarli (riducendo la ridondanza)

Allo stesso tempo, visto che abbiamo bisogno che il Cane fa un verso specifico, possiamo sovrascrivere il metodo FaiVerso()
Questo è un concetto principalmente del polimorfismo, ma è utile per far capire come le sottoclassi possono utilizzare o non i metodi delle superclassi

# Cos'è e cosa fa il polimorfismo, fai degli esempi pratici

Il polimorfismo è uno dei principi fondamentali della OOP.

Provvede l'intercambiabilità tra i tipi.
Ci permette di trattare un oggetto di una sottoclasse come se fosse un istanza della superclasse.

Questo ci permette di avere del codice molto più generico, dove possiamo usare "presumere" di star lavorando su una superclasse, mentre il funzionamento reale del programma dipende dalle sottoclassi istanziate.
Questo è polimorfismo Run-Time, dove all'esecuzione la macchina decide quali metodi utilizzare in base all'oggetto.

Esempio:

class Animale
	public void GetAnimale()
		Print("Sono un Animale");

class Cane : Animale
	public override void GetAnimale()
		Print("Sono un Cane");

class Gatto : Animale
	public override void GetAnimale()
		Print("Sono un Gatto");

void GestisciAnimale(Animale a)
	a.GetAnimale();

GestisciAnimale(new Cane);
GestisciAnimale(new Gatto);

In questo esempio, la nostra funzione GestisciAnimale "presume" di star lavorando su un oggetto di tipo Animale, ma grazie al polimorfismo possiamo sostituire il parametro con oggetti di sottoclasse di Animale.
La macchina poi, vedendo che le sottoclassi hanno OVERRIDE di GetAnimale() utilizzerà quei metodi. Se non ci fosse stato l'override, invece la macchina sarebbe risalita in ogni superclasse finché non trova un metodo override oppure il metodo originale in Animale.

Esiste pure il polimorfismo Compile-Time.
Questo avviene tramite l'OVERLOAD.

Possiamo definire molteplici metodi con lo stesso nome, ma con parametri e return diversi (firma), e in base a quali parametri usiamo la macchina riconosce il metodo giusto.
Questo avviene prima della esecuzione, ovvero durante la compilazione.

Esempio:

public int Somma(int a, int b)
	return a + b;

public int Somma(int a, int b, int c)
	return a + b + c;

public float Somma(float a, float b)
	return a + b;

Somma(1, 2);
Somma(1, 2, 3);
Somma(1.5f, 2.3f);

In questo caso possiamo avere vari metodi con lo stesso nome, e la scelta di quale metodo utilizzare avviene alla compilazione, esaminando i parametri inseriti.

# Cos'è la DevOPS e quali sono le sue fasi principali?

La DevOps è la disciplina che unisce le operazioni aziendali con lo sviluppo del software.
Permette al reparto di programmazione di collaborare bene tra i suoi membri, e con gli altri reparti dell'azienda.

Le sue fasi principali sono: lo sviluppo, il monitoraggio, la distribuzione.

I suoi vari aspetti come il version control e il testing ci assicura che tutti i programmatori lavorino sulla stessa versione e rispettino requisiti tecnici.
Inoltre permette di seguire i requisiti per essere disponibile a quanti più utenti, sia per requisiti tecnici che legali.